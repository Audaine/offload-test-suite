#--- vertex.hlsl
struct PSInput {
  float4 position : SV_POSITION;
  float2 uv : TEXCOORD;
};
Texture2D<float4> Tex;

PSInput main(float3 position : POSITION, float2 uv : TEXCOORD) {
  PSInput result;
  result.position = float4(position, 1.0);
  result.uv = uv * Tex[uv];
  return result;
}

#--- pixel.hlsl
struct PSInput {
  float4 position : SV_POSITION;
  float2 uv : TEXCOORD;
};

Texture2D<float> g_tex : register(t0);

float4 main(PSInput input) : SV_TARGET {
  int3 offset = int3((input.uv * 64.0) % 4, 0);
  float val = g_tex.Load(offset);
  return float4(ddx_fine(val), ddy_fine(val), ddx_coarse(val), ddy_coarse(val));
}
#--- pipeline.yaml
---
Shaders:
  - Stage: Vertex
    Entry: main
  - Stage: Pixel
    Entry: main
Buffers:
  - Name: VertexData
    Format: Float32
    Stride: 20
    Data: [ -1.0, 1.0, 0.0, 0.0, 0.0,
            1.0, 1.0, 0.0, 1.0, 0.0,
            -1.0, -1.0, 0.0, 0.0, 1.0,
            -1.0, -1.0, 0.0, 0.0, 1.0,
            1.0, 1.0, 0.0, 1.0, 0.0,
            1.0, -1.0, 0.0, 1.0, 1.0 ]
  - Name: Texture
    Format: Float32
    Channels: 1
    Data: [ 0.125, 0.25, 0.5, 1.0,
            2.0, 4.0, 16.0, 32.0,
            32.0, 64.0, 128.0, 256.0,
            256.0, 512.0, 1024.0, 2048.0]
Bindings:
  VertexBuffer: VertexData
DescriptorSets:
  - Resources:
    - Name: Texture
      Kind: Texture2D
      DirectXBinding:
        Register: 0
        Space: 0
...
#--- end

# UNSUPPORTED: Clang
# RUN: split-file %s %t

# RUN: split-file %s %t
# RUN: %dxc_target -T vs_6_0 -Fo %t-vertex.o %t/vertex.hlsl
# RUN: %dxc_target -T ps_6_0 -Fo %t-pixel.o %t/pixel.hlsl
# RUN: %if Metal %{ mv %t-vertex.o %t-vertex.dxil && mv %t-pixel.o %t-pixel.dxil %}
# RUN: %if Metal %{ metal-shaderconverter %t-vertex.dxil -o=%t-vertex.o %}
# RUN: %if Metal %{ metal-shaderconverter %t-pixel.dxil -o=%t-pixel.o %}
# RUN: %offloader %t/pipeline.yaml %t-vertex.o %t-pixel.o | FileCheck %s
